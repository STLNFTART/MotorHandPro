#!/usr/bin/env python3
"""
PrimalLang Code Generator - Transpiles AST to Python
Generates efficient NumPy-based code with Donte & Lightfoot constants
"""
from typing import List, Union
from .parser import *


class PythonCodeGenerator:
    """Generates Python code from PrimalLang AST"""

    def __init__(self):
        self.indent_level = 0
        self.code_lines: List[str] = []
        self.in_function = False

    def generate(self, ast: Program) -> str:
        """Generate Python code from AST"""
        self.code_lines = []
        self.indent_level = 0

        # Add imports
        self._emit("#!/usr/bin/env python3")
        self._emit('"""')
        self._emit("Generated by PrimalLang Compiler")
        self._emit("Uses Donte & Lightfoot Constants")
        self._emit('"""')
        self._emit("import numpy as np")
        self._emit("import math")
        self._emit("from primallang.runtime.primitives import (")
        self._emit("    PrimalConstants, Vector384, Matrix384,")
        self._emit("    MathPrimitives, MetaChecker, MetaError")
        self._emit(")")
        self._emit("")
        self._emit("# Load Primal Constants and math functions")
        self._emit("_constants = PrimalConstants.get_all()")
        self._emit("globals().update(_constants)")
        self._emit("# Load math functions into global scope")
        self._emit("exp, sin, cos, tan, log, sqrt, abs, floor, ceil, round = \\")
        self._emit("    math.exp, math.sin, math.cos, math.tan, math.log, \\")
        self._emit("    math.sqrt, abs, math.floor, math.ceil, round")
        self._emit("")

        # Generate statements
        for stmt in ast.statements:
            self._generate_statement(stmt)

        return '\n'.join(self.code_lines)

    def _generate_statement(self, stmt: Statement):
        """Generate code for a statement"""
        if isinstance(stmt, LetStatement):
            self._generate_let(stmt)
        elif isinstance(stmt, Assignment):
            self._generate_assignment(stmt)
        elif isinstance(stmt, FunctionDef):
            self._generate_function_def(stmt)
        elif isinstance(stmt, ReturnStatement):
            self._generate_return(stmt)
        elif isinstance(stmt, ForLoop):
            self._generate_for_loop(stmt)
        elif isinstance(stmt, WhileLoop):
            self._generate_while_loop(stmt)
        elif isinstance(stmt, IfStatement):
            self._generate_if_statement(stmt)
        elif isinstance(stmt, UniverseDecl):
            self._generate_universe(stmt)
        elif isinstance(stmt, EvolveStatement):
            self._generate_evolve(stmt)
        elif isinstance(stmt, MetaConstraint):
            self._generate_meta_constraint(stmt)
        elif isinstance(stmt, PrintStatement):
            self._generate_print(stmt)
        elif isinstance(stmt, Block):
            self._generate_block(stmt)
        else:
            # Expression statement
            expr_code = self._generate_expression(stmt)
            self._emit(expr_code)

    def _generate_let(self, stmt: LetStatement):
        """Generate variable declaration"""
        value_code = self._generate_expression(stmt.value)
        if stmt.is_constant:
            # Constants are uppercase
            self._emit(f"{stmt.name.upper()} = {value_code}")
        else:
            self._emit(f"{stmt.name} = {value_code}")

    def _generate_assignment(self, stmt: Assignment):
        """Generate assignment"""
        value_code = self._generate_expression(stmt.value)

        if isinstance(stmt.target, Identifier):
            self._emit(f"{stmt.target.name} = {value_code}")
        elif isinstance(stmt.target, IndexAccess):
            array_code = self._generate_expression(stmt.target.array)
            index_code = self._generate_expression(stmt.target.index)
            self._emit(f"{array_code}[{index_code}] = {value_code}")

    def _generate_function_def(self, stmt: FunctionDef):
        """Generate function definition"""
        params = ', '.join(stmt.parameters)
        self._emit(f"def {stmt.name}({params}):")
        self.indent_level += 1
        self.in_function = True

        if not stmt.body.statements:
            self._emit("pass")
        else:
            for s in stmt.body.statements:
                self._generate_statement(s)

        self.in_function = False
        self.indent_level -= 1
        self._emit("")  # Blank line after function

    def _generate_return(self, stmt: ReturnStatement):
        """Generate return statement"""
        if stmt.value is None:
            self._emit("return")
        else:
            value_code = self._generate_expression(stmt.value)
            self._emit(f"return {value_code}")

    def _generate_for_loop(self, stmt: ForLoop):
        """Generate for loop"""
        start_code = self._generate_expression(stmt.start)
        end_code = self._generate_expression(stmt.end)

        # Convert to Python range (inclusive end)
        self._emit(f"for {stmt.variable} in range(int({start_code}), int({end_code}) + 1):")
        self.indent_level += 1

        if not stmt.body.statements:
            self._emit("pass")
        else:
            for s in stmt.body.statements:
                self._generate_statement(s)

        self.indent_level -= 1

    def _generate_while_loop(self, stmt: WhileLoop):
        """Generate while loop"""
        condition_code = self._generate_expression(stmt.condition)
        self._emit(f"while {condition_code}:")
        self.indent_level += 1

        if not stmt.body.statements:
            self._emit("pass")
        else:
            for s in stmt.body.statements:
                self._generate_statement(s)

        self.indent_level -= 1

    def _generate_if_statement(self, stmt: IfStatement):
        """Generate if statement"""
        condition_code = self._generate_expression(stmt.condition)
        self._emit(f"if {condition_code}:")
        self.indent_level += 1

        if not stmt.then_block.statements:
            self._emit("pass")
        else:
            for s in stmt.then_block.statements:
                self._generate_statement(s)

        self.indent_level -= 1

        if stmt.else_block:
            self._emit("else:")
            self.indent_level += 1

            if not stmt.else_block.statements:
                self._emit("pass")
            else:
                for s in stmt.else_block.statements:
                    self._generate_statement(s)

            self.indent_level -= 1

    def _generate_universe(self, stmt: UniverseDecl):
        """Generate universe declaration"""
        self._emit(f"# Universe: {stmt.name}")
        self._emit(f"{stmt.name} = {{'type': 'universe', 'name': '{stmt.name}'}}")

    def _generate_evolve(self, stmt: EvolveStatement):
        """Generate evolve statement"""
        self._emit(f"# Evolve {stmt.universe} with {stmt.function}")
        self._emit(f"# TODO: Implement evolution dynamics")

    def _generate_meta_constraint(self, stmt: MetaConstraint):
        """Generate meta-constraint check"""
        condition_code = self._generate_expression(stmt.condition)

        # Extract premise and conclusion for implies operator
        if isinstance(stmt.condition, BinaryOp) and stmt.condition.operator == 'implies':
            premise_code = self._generate_expression(stmt.condition.left)
            conclusion_code = self._generate_expression(stmt.condition.right)

            self._emit(f"# Meta-constraint verification")
            self._emit(f"MetaChecker.check_implies(")
            self.indent_level += 1
            self._emit(f"{premise_code},")
            self._emit(f"{conclusion_code},")
            self._emit(f"premise_str='{premise_code}',")
            self._emit(f"conclusion_str='{conclusion_code}'")
            self.indent_level -= 1
            self._emit(")")
        else:
            # General boolean constraint
            self._emit(f"# Meta-constraint: assert {condition_code}")
            self._emit(f"if not ({condition_code}):")
            self.indent_level += 1
            self._emit(f"raise MetaError(0, 'constraint', '{condition_code}', [])")
            self.indent_level -= 1

    def _generate_print(self, stmt: PrintStatement):
        """Generate print statement"""
        expr_code = self._generate_expression(stmt.expression)
        func_name = "display" if stmt.is_display else "print"
        self._emit(f"print({expr_code})")

    def _generate_block(self, stmt: Block):
        """Generate block"""
        for s in stmt.statements:
            self._generate_statement(s)

    def _generate_expression(self, expr: Expression) -> str:
        """Generate code for an expression"""
        if isinstance(expr, Number):
            return str(expr.value)

        elif isinstance(expr, String):
            # Handle string concatenation with + operator
            return f'"{expr.value}"'

        elif isinstance(expr, Boolean):
            return "True" if expr.value else "False"

        elif isinstance(expr, Identifier):
            # Map special identifiers to primitives
            special_names = {
                'sqrt': 'math.sqrt',
                'sin': 'math.sin',
                'cos': 'math.cos',
                'tan': 'math.tan',
                'exp': 'math.exp',
                'log': 'math.log',
                'abs': 'abs',
                'floor': 'math.floor',
                'ceil': 'math.ceil',
                'round': 'round',
            }
            return special_names.get(expr.name, expr.name)

        elif isinstance(expr, ArrayLiteral):
            if not expr.elements:
                # Empty array - create as list that can grow
                return "[]"
            else:
                elements = [self._generate_expression(e) for e in expr.elements]
                return f"[{', '.join(elements)}]"

        elif isinstance(expr, BinaryOp):
            return self._generate_binary_op(expr)

        elif isinstance(expr, UnaryOp):
            operand_code = self._generate_expression(expr.operand)
            if expr.operator == 'not':
                return f"(not {operand_code})"
            else:
                return f"({expr.operator}{operand_code})"

        elif isinstance(expr, IndexAccess):
            array_code = self._generate_expression(expr.array)
            index_code = self._generate_expression(expr.index)
            return f"{array_code}[int({index_code})]"

        elif isinstance(expr, FunctionCall):
            return self._generate_function_call(expr)

        else:
            raise ValueError(f"Unknown expression type: {type(expr)}")

    def _generate_binary_op(self, expr: BinaryOp) -> str:
        """Generate binary operation"""
        left_code = self._generate_expression(expr.left)
        right_code = self._generate_expression(expr.right)

        op_map = {
            '+': '+',
            '-': '-',
            '*': '*',
            '/': '/',
            '%': '%',
            '^': '**',  # Power operator
            '==': '==',
            '!=': '!=',
            '<': '<',
            '>': '>',
            '<=': '<=',
            '>=': '>=',
            'and': 'and',
            'or': 'or',
            'implies': 'or',  # A implies B = (not A) or B
        }

        op = op_map.get(expr.operator, expr.operator)

        if expr.operator == 'implies':
            # A implies B = (not A) or B
            return f"((not {left_code}) or {right_code})"
        else:
            return f"({left_code} {op} {right_code})"

    def _generate_function_call(self, expr: FunctionCall) -> str:
        """Generate function call"""
        args = [self._generate_expression(arg) for arg in expr.arguments]

        # Special handling for built-in functions
        if expr.name == 'integrate':
            # integrate('expr', a, b) or integrate(func, a, b)
            if len(args) == 3:
                if isinstance(expr.arguments[0], String):
                    # String expression - create lambda
                    expr_str = expr.arguments[0].value
                    return f"MathPrimitives.integrate(lambda x: {expr_str}, {args[1]}, {args[2]})"
                else:
                    return f"MathPrimitives.integrate({args[0]}, {args[1]}, {args[2]})"
            else:
                raise ValueError(f"integrate requires 3 arguments, got {len(args)}")

        elif expr.name == 'derivative':
            # derivative('expr', x) or derivative(func, x)
            if len(args) >= 2:
                if isinstance(expr.arguments[0], String):
                    expr_str = expr.arguments[0].value
                    return f"MathPrimitives.derivative(lambda x: {expr_str}, {args[1]})"
                else:
                    return f"MathPrimitives.derivative({args[0]}, {args[1]})"
            else:
                raise ValueError(f"derivative requires at least 2 arguments, got {len(args)}")

        elif expr.name == 'make_fill' or expr.name == 'fill':
            # Vector fill operation
            if len(args) == 1:
                return f"Vector384.fill({args[0]})"
            else:
                raise ValueError(f"fill requires 1 argument, got {len(args)}")

        elif expr.name == 'zeros':
            return "Vector384.zeros()"

        elif expr.name == 'ones':
            return "Vector384.ones()"

        elif expr.name == 'dot':
            # Dot product
            if len(args) == 2:
                return f"{args[0]}.dot({args[1]})"
            else:
                raise ValueError(f"dot requires 2 arguments, got {len(args)}")

        elif expr.name == 'norm':
            # Vector norm
            if len(args) == 1:
                return f"{args[0]}.norm()"
            else:
                raise ValueError(f"norm requires 1 argument, got {len(args)}")

        else:
            # Regular function call
            args_str = ', '.join(args)
            return f"{expr.name}({args_str})"

    def _emit(self, code: str):
        """Emit a line of code with proper indentation"""
        indent = '    ' * self.indent_level
        self.code_lines.append(indent + code)


def compile_to_python(source: str) -> str:
    """
    Compile PrimalLang source code to Python
    """
    from .parser import parse

    ast = parse(source)
    generator = PythonCodeGenerator()
    return generator.generate(ast)


__all__ = ['PythonCodeGenerator', 'compile_to_python']
